---
title: "Exercise Solution"
output: html_notebook
---

---
# Visualising the Spatial Distirbution of MSOA Accessibility to Green Space

Geospatial-statistical analysis of MSOA accessibility to publicly accessible
green spaces in Greater London.

---

## National Statistics Postcode Lookup

* The [National Statistics Postcode Lookup
(NSPL)](https://www.ons.gov.uk/methodology/geography/geographicalproducts/postcodeproducts)
can be used to allocate your source statistics at postcode-level to a wide range
of higher UK statistical and administrative geographies.
* The NSPL does the by allocating UK postcodes to Output Areas (OA). These OAs
are then referenced to a wide range of higher statistical geographies (for
example, local authority districts [LADs]) by a best-fit methodology that uses
Census population data.
* The postcode centroid point geometry provides the 1-meter grid reference
location (x, y) of the mean address in the postcode snapped to the nearest
property.
* We'll use the NSPL for postcode centroid point geometries and for the
references to Middle Layer Super Output Area (MSOA) and Regions.

## OS Open Greenspace

The OS OpenData product [OS Open
Greenspace](https://www.ordnancesurvey.co.uk/business-government/products/open-map-greenspace)
depicts the location and extent of spaces such as parks and sports facilities
that are likely to be accessible to the public. Where appropriate, it also
includes Access Points to show how people get into these sites. Its primary
purpose is to enable members of the public to find and access greenspaces near
them for exercise and recreation.

![Example of the OS Open Greenspace product.](https://beta.ordnancesurvey.co.uk/img-assets/products/greenspace-open-london.x5201e7a5.jpg?w=1242&h=828&crop=828%2C828%2C207%2C0&f=webp?q=100&crop=2270,1422,0,0&w=1000)

## Middle Layer Super Output Areas

* Middle Layer Super Output Areas (MSOAs) are an ONS census geography product
comprised of nested OAs and LSOAs and providing a geographical unit for census
data releases.
* The postcodes in the NSPL are allocated to OAs by plotting each postcode's
centroid directly into the OA boundaries. The postcodes are then allocated to
the higher geographies that the postcode's OA falls in by plotting the OA's
population-weighted centroid into the digital boundary of the higher geography.
A population-weighted centroid is a grid reference that in a single summary
point reflects the spatial distribution of the 2021 Census population in the OA.

---

```{r}
library(sf)
library(httr)
library(jsonlite)
library(tmap)
library(dplyr)
library(ggplot2)
```

## NSPL

1. Read the NSPL CSV data into a data frame.
2. Return the head of the data frame
3. List all columns of the data frame.
4. Count the rows.
5. Subset the data frame only keeping live postcodes (`doterm` is `NULL`)
referencing the Greater London region (`rgn` equal to `E12000007`).
6. Rename the following columns: `oseast1m` to `x`, `osnrth1m` to `y`, `msoa11`
to `msoa11cd` and `rgn` to `rgn20cd`.
7. Count the rows in the subset.
8. Construct an `sf` object from the data frame with the geometry column
representing a point type constructed from the postcode centroid x and y
coordinates.
9. Assign the data frame CRS to British National Grid (EPSG:27700).
10. Return the CRS assignment.
11. Count rows by geometry type.
12. Check geometry validity.
13. Create a static plot of the subset `sf` object. Use a qualitative colour hex
value from the GDV toolkit and reduce the marker size and marker transparency to
create a dot-density map.

```{r}
# Read the NSPL CSV data into a data frame
nspl <- read.csv('../../data/office-for-national-statistics/nspl-feb-2023-uk.csv')

# Return the head of the data.frame
head(nspl)
```

```{r}
# List all columns of the data frame
names(nspl)
```

```{r}
# Count the rows
nrow(nspl)
```

```{r}
# Subset the data frame only keeping live postcodes
nspl <- nspl[is.na(nspl$doterm) &  # Live postcodes have a NA termination date in the 'doterm' column
               nspl$rgn == 'E12000007',  # Already subset to the Greater London Region (GSS code equal to 'E12000007')
             c('pcds', 'oseast1m', 'osnrth1m', 'msoa11', 'rgn')]
```

```{r}
# Rename columns
names(nspl) <- replace(setNames(nm = names(nspl)), 
                       c('oseast1m', 'osnrth1m', 'msoa11', 'rgn'),  # Original names
                       c('x', 'y', 'msoa11cd', 'rgn20cd'))  # Modified names
```

```{r}
# Count the rows in the subset
nrow(nspl)
```

```{r}
# Construct an sf object from the data frame.
# The geometry column is a point type constructed from the postcode centroid x and y
nspl_gdf <- st_as_sf(nspl, 
                     coords = c('x', 'y'),  # Specify the columns with coordinates
                     crs = 27700)  # Set CRS to BNG (EPSG:27700)
```

```{r}
# Return the CRS assignment
st_crs(nspl_gdf)
```

```{r}
# Count row by geometry type
table(st_geometry_type(nspl_gdf))
```

```{r}
# Check geometry validity
table(st_is_valid(nspl_gdf))
```

```{r, fig.width = 10, fig.height = 10}
# Create a static plot of the subset data frame
tmap_mode('plot')
nspl_plot <- tm_shape(nspl_gdf) + 
              tm_dots(col = '#af58ba', alpha = 0.2)

nspl_plot
```

## OS Open Greenspace

1. Read the `greenspace_site` layer from the GPKG dataset into an `sf` data
frame.
2. Subset columns (keeping only `id`, `function` and `geometry`) and filter for
green space function `Public Park Or Garden` or `Playing Field`.
3. Return the head of the data frame
4. Count the rows.
5. Count rows by geometry type.
6. Check geometry validity.
7. Create a static plot of the centroid of each MultiPolygon geometry. Use a
qualitative colour hex value from the GDV toolkit.

```{r}
# Read the GreenspaceSite layer from the GPKG dataset
osogs <- st_read('../../data/ordnance-survey/os-open-greenspace-gb.gpkg',
                 layer = 'greenspace_site')  # Specify the GPKG feature table / layer

# Subset columns and filter for green space function 'Public Park Or Garden' or 'Playing Field'
osogs <- osogs[osogs$function. %in% c('Public Park Or Garden', 'Playing Field'),
               c('id', 'function.', 'geometry')]

# Return the head of the data frame
head(osogs)
```

```{r}
# Count the rows
nrow(osogs)
```

```{r}
# Count rows by geometry type
table(st_geometry_type(osogs))
```

```{r}
# Check geometry validity
table(st_is_valid(osogs))
```

```{r, fig.width = 6, fig.height = 8}
# Create a static plot of the centroid of each MultiPolygon geoemtry
# Follow GDV best practice
osogs_plot <- tm_shape(st_centroid(osogs)) + 
                tm_dots(col = '#00cd6c', alpha = 0.2)

osogs_plot
```

## Spatially join the NSPL and OS Open Greenspace

1. Spatially join the rows within the `nspl` and `osogs` data frames where pairs
of geometries are the closest feature.
  * While you can use `st_join` or `st_is_within_distance` these functions can
  be quite slow.
  * Using `st_nearest_feature` or `st_intersects` (with a buffer) tends to be
  much faster.
  * Create a column called 'distance' which shows the distance between the pairs
  of geometries.
  * Ensure that every postcode in the `nspl` data frame is retained within the
  join.
2. Return the head of the data frame.
3. Count the rows.
4. Count the number of unique postcodes - what can you glean by comparing
against the total row count?
5. Check that the number of unique postcodes is equal to the number of postcodes
in Greater London in the subset of the NSPL.
6. Calculate the minimum distance to a green space per MSOA Do this by
grouping by the `msoa11cd` column of the nearest distance per postcode data
frame.
7. Return the head of the data frame.
8. Return the data frame descriptive statistics.
9. Plot an MSOA-distance histogram.
10. Population a new 'rank' column binning each MSOA into one of seven classes,
ordering by the mean distance.
11. Return the head of the data frame.
12. Count the rows.
13. Check that the number of MSOAs is equal to the number of unique MSOAs in
Greater London in the subset of the NSPL.

```{r}
# Spatially join the rows within the nspl and osogs data.frames 

# Find nearest green space
nearId <- st_nearest_feature(nspl_gdf, osogs)
# This returns a vector with a row ID in `osogs` for each NSPL record

# Join the two data frames by expansion
nspl2osogs <- cbind(nspl_gdf, osogs[nearId, ])

# Examine this new data.frame
head(nspl2osogs)
```

```{r}
# Calculate the distance between each pair: NSPL -- green space
nspl2osogs$distance <- st_distance(nspl2osogs$geometry, 
                                   nspl2osogs$geometry.1, 
                                   by_element = TRUE)
# Remove 'units'
nspl2osogs$distance <- as.numeric(nspl2osogs$distance)

# Drop the green space geometry (no longer needed)
nspl2osogs$geometry.1 <- NULL
```

```{r}
# Count the rows
nrow(nspl2osogs)
```

```{r}
# Count the number of unique postcodes
length(unique(nspl2osogs$pcds))
```

```{r}
# Check that the number of unique postcodes is equal to the postcodes in the
# Greater London subset of the NSPL
length(unique(nspl2osogs$pcds)) == length(unique(nspl_gdf$pcds))
```

```{r}
# Calculate the mean distance to a green space per MSOA
# Do this by grouping by the msoa11cd of the distance 
msoa_mean <- aggregate(list('distance' = nspl2osogs$distance), 
                       by = list('msoa11cd' = nspl2osogs$msoa11cd), 
                       mean)

# Return the head of the data frame
head(msoa_mean)
```

```{r}
# Return data frame descriptive statistics
summary(msoa_mean)
```

```{r, fig.width = 8, fig.height = 6}
# Plot a MSOA-mean distance histogram
ggplot(msoa_mean, aes(x = distance)) +
  geom_histogram(bins = 50,
                 fill = 'lightblue', 
                 color = 'blue') +
  xlab('Area') +
  ylab('Frequency') +
  ggtitle('Distribution of Mean MSOA Postcode to Greenspace Distances')
```

```{r}
# Populate a new #rank' column binning each MSOA into one of seven classes
# ordering by the mean distance.
# Specify rank labels 1-7.

# Get quantile break points for seven groups
qdist <- quantile(msoa_mean$distance, 
                  probs = (0:7) / 7)

# Populate rank column
msoa_mean$rank <- cut(msoa_mean$distance, 
                      breaks = qdist, 
                      labels = 1:7,
                      include.lowest = TRUE)

# Return head of data frame
head(msoa_mean)
```

```{r}
# Count the rows
nrow(msoa_mean)
```

```{r}
# Check that the number of MSOAs is equal to the number of unique MSOAs in
# Greater London in the subset of the NSPL
nrow(msoa_mean) == length(unique(nspl$msoa11cd))
```

## MSOA Boundaries

1. Read the MSOA GeoPackage (GPKG) dataset into an `sf` data frame.
2. Return the head of the data frame.
3. Count the rows.
4. Subset the columns keeping only `MSOA11CD` and `SHAPE`.
5. Rename `MSOA11CD` column to `msoa11cd`.
6. Count rows by geometry type.
7. Check geometry validity.
8. Inner join (by attribute) the rows within this `msoa` data frame and the
`msoa_mean` data frame on the `msoa11cd` column.
9. Return the head of the data frame.
10. Count the rows.

```{r}
# Read GPKG into an `sf` data.frame.
msoa <- st_read('../../data/office-for-national-statistics/msoa-dec-2011-boundaries-bfc-ew.gpkg')

# Return the head of the data.frame
head(msoa)
```

```{r}
# Count the rows
nrow(msoa)
```

```{r}
# Subset the columns
msoa <- msoa[, c('MSOA11CD', 'SHAPE')]
```

```{r}
# Rename the columns
names(msoa)[1] <- 'msoa11cd'
# If you try to rename the geometry column, need to use `st_geometry(x)<-`
```

```{r}
# Count the rows by geometry type
table(st_geometry_type(msoa))
```

```{r}
# Check geometry validity
table(st_is_valid(msoa))
```

```{r}
# Inner join (by attribute) the rows within the msoa data frame and the
# msoa_mean data frame on the `msoa11cd` column
msoa_mean_gdf <- merge(msoa, 
                       msoa_mean, 
                       by = 'msoa11cd', 
                       all.x = FALSE)  # creates an inner join

# Return the head of the data frame
head(msoa_mean_gdf)
```

```{r}
# Count the rows
nrow(msoa_mean_gdf)
```

## OS GeoDataViz Sequential Palette

1. Download and decode the JSON representations of the OS [GDV colour
palettes](https://raw.githubusercontent.com/OrdnanceSurvey/GeoDataViz-Toolkit/master/Colours/GDV-colour-palettes-v0.7.json)
via an HTTP GET request.
2. Access the `m2` colour palette within the `sequential` palette group.
3. Return and display the colour map. 

```{r}
# Download and decode the JSON representation of the OS GDV colour palettes via
# an HTTP GET request
gdv <- 'https://raw.githubusercontent.com/OrdnanceSurvey/GeoDataViz-Toolkit/master/Colours/GDV-colour-palettes-v0.7.json'

# Make HTTP GET request and decode JSON
gdv_json <- GET(url = gdv)
gdv_json <- fromJSON(content(gdv_json))

# Get colour hex values
gdv_cmap <- gdv_json$sequential$m2

# Show an example of the colours
(image(1:length(gdv_cmap), 1, as.matrix(1:length(gdv_cmap)), 
      col = gdv_cmap,
      xlab="", ylab = "", xaxt = "n", yaxt = "n", bty = "n"))
```

### Static Map

1. Create a static plot overlaying the centroids of the `osogs` spatial data
frame, within the Greater London bounding region, on top of a choropleth map
showing MSOA mean distance to green space, from the `msoa_mean_gdf` spatial data
frame. The map should be styled using GDV best practice and the mean distance
coloured using the `m2` GDV colour map against the `rank` bin column.

```{r}
# Store a plot of the msoa_mean_gdf data frame
msoa_plot <- tm_shape(msoa_mean_gdf) + 
                tm_polygons(col = 'rank',  # column name
                            palette = gdv_cmap,  # colour palette
                            style = 'cat')  # use a categorical classification
```

```{r}
# Clip the osogs data frame to the bounding box of Greater London
bbox <- st_as_sfc(st_bbox(msoa_mean_gdf), crs = 27700)

# Filter green space based on intersecting features
osogs <- osogs[bbox, ]
```

```{r, fig.width = 10, fig.height = 10}
# Plot the centroid of each geometry in the osogs data frame and add to the msoa
# plot
final_plot <- msoa_plot + 
                tm_shape(st_centroid(osogs)) + 
                tm_dots(col = '#06592a', alpha = 0.75)

final_plot
```

### Interactive Map

1. Create an interactive map using `tmap` (set `tmap_mode('view')`) showing MSOA
mean distance to green space, from the `msoa_mean_gdf` data frame. The map
should be styped using GDV best practices and the mean distance coloured using
the `m2` GDV colour map against the `rank` bin column. The map should use an OS
Maps API Light Style 3857 base map.
  * Note: This step can use the `msoa_plot` as an overlay to a basemap.

```{r}
# OS Maps API layer
# Example uses Light Style in Web Mercator (EPSG:3857) projection
layer <- 'Light_3857'

# OS Data Hub project API key
key <- '7UTXMMWsGjjIzcBmLdAGnMO6WEAQi9Ng'
```

```{r}
# Define the tile server parameters for the basemap
url <- paste0('https://api.os.uk/maps/raster/v1/zxy/', layer,
              '/{z}/{x}/{y}.png?key=', key)
```

```{r, fig.width = 10, fig.height = 10}
# Create the interactive map the OS Maps API base map
tmap_mode('view')

m <- msoa_plot +  # starting with the previous map layer
      tm_basemap(server = url)

# m
```

```{r}
# Return setting to static plot mode.
tmap_mode('plot')
```

---

## Extension: Quantifying accessibility via a different metric

Finding the distance to each postcode's nearest green space isn't the only way
to quantify accessibility to green space. Considering that the area (utility) of
a green space site may be an important factor in conjunction with distance, one
alternative could be to measure the total area of green space within a certain
distance of each postcode.

1. Create a new data frame by buffering the NSPL postcode POINT geometries in
the `nspl_gdf` data.frame by a threshold distance.
2. Add a new column to the data frame representing the area of the new POLYGON
geometry for each postcode.
3. Return the head of the data frame.

```{r}
# Distance (buffer) threshold in metres
distance_threshold <- 500

# Buffer the postcode POINT geometries by the threshold distance.
# This transforms the geometry type from POINT --> POLYGON
pcds_buffer <- st_buffer(nspl_gdf, dist = distance_threshold)

# Add a new column representing the area of the new POLYGON geometry for each
# postcode.
pcds_buffer$threshold_area <- st_area(pcds_buffer)

# Return the head of the data frame
head(pcds_buffer)
```

4. Create a new data frame by evaluating the intersection (shared geometry)
between the buffered postcode POLYGON geometries and the OS Open GreenSpace data
in the `osog`s data frame.

```{r}
# Evaluate the intersection (shared geometry) between the buffered postcode
# POLYGON geometries and the OS Open GreenSpace data in the `osogs` data frame.
pcds_buffer_osogs_int <- st_intersection(pcds_buffer, osogs)
```

5. Find the area of overlap.
  * Option 1: (Faster)
    + Add a new column to the data frame representing the area of each overlay.
    + Aggregate (sum) the area parts by postcode. 
  * Option 2: (Slow!)
    + Dissolve (spatially union) the intersection geometries by postcode
    + Add a new column to the data frame representing the area of the
    intersection geometry by postcode.
6. Return the head of the data frame.

```{r}
# Option 1

# Add a new column to the data frame representing the area of the intersection
# geometry for each part.
pcds_buffer_osogs_int$area <- st_area(pcds_buffer_osogs_int)

# Aggregate (sum) the area of parts for each postcode
pcds_buffer_osogs_int <- aggregate(list('area' = pcds_buffer_osogs_int$area),
                                   by = list('pcds' = pcds_buffer_osogs_int$pcds),
                                   sum)

# Return the head of the data frame (now a tibble)
head(pcds_buffer_osogs_int)
```

```{r, eval=FALSE}
# Option 2

# Evaluate the intersection (shared geometry) between the buffered postcode
# POLYGON geometries and the OS Open GreenSpace data in the `osogs` data frame.
pcds_buffer_osogs_int <- st_intersection(pcds_buffer, osogs)

# Dissolve (spatially union) the intersection geometries by postcode
# Caution: this step may take some time!
# Note: using `dplyr` tools
pcds_buffer_osogs_int <- group_by(pcds_buffer_osog_int, pcds) %>% 
                          summarise()

# Add a new column to the data frame representing the area of the intersection
# geometry by postcode.
pcds_buffer_osogs_int$area <- st_area(pcds_buffer_osog_int)

# Return the head of the data frame (now a tibble)
head(pcds_buffer_osogs_int)
```

7. A subset of postcodes will not be represented in the data because the
buffered POLYGON geometry does not intersect any of the OS Open GreenSpace
feature geometries. Add the missing subset of postcodes to the data by merging
to the buffered postcode data.
8. Add a new column to the data frame representing a normalised area metric -
divide the intersection geometry area by the area of the buffered postcode
geometry.
9. Set the normalised area metric to a value of 0 for any missing data.
10. Return the head of the data frame.

```{r}
# Add the missing subset of postcodes to the data by a left merge
pcds_buffer_osogs_int <- merge(st_drop_geometry(pcds_buffer),  # Exclude geometry
                               pcds_buffer_osogs_int, 
                               by = 'pcds',  # Shared column name
                               all.x = TRUE)  # Left join
# Add a new column to the data frame representing a normalised area metric -
# divide the intersection geometry area by the area of the buffered postcode
# geometry.
pcds_buffer_osogs_int$area_normalised <- pcds_buffer_osogs_int$area / 
                                          pcds_buffer_osogs_int$threshold_area
# Remove units
pcds_buffer_osogs_int$area_normalised <- as.numeric(pcds_buffer_osogs_int$area_normalised)

# Set the normalised area metric to 0 anywhere the value is missing
pcds_buffer_osogs_int[is.na(pcds_buffer_osogs_int$area_normalised), 
                      'area_normalised'] <- 0

# Return the head of the data frame
head(pcds_buffer_osogs_int)
```

11. Test whether the number of rows in the NSPL and postcode normalised area
datasets are equal.

```{r}
# Test whether the number of rows in the NSPL and postcode normalised area
# datasets are equal.
nrow(nspl) == nrow(pcds_buffer_osogs_int)
```
12. Plot a histogram of the distribution of postcode normalised area values.

```{r}
# Plot a histogram of the distribution of postcode normalised area values
# The normalised area metric is very biased towards small values
# Right-skewed (long right tail)
ggplot(pcds_buffer_osogs_int, aes(x = area_normalised)) +
  geom_histogram(fill = 'blue', bins = 50)
```
13. Summarise the postcode normalised area at MSOA-level by calculating the mean
area by MSOA.

```{r}
# Summarise the postcode normalised area at MSOA-level by calculating the mean
# area by MSOA

# Subset the columns
pcds_buffer_osogs_int <- pcds_buffer_osogs_int[, c('msoa11cd', 'area_normalised')]

# Group by msoa11cd key
msoa_area <- aggregate(list('area_normalised' = pcds_buffer_osogs_int$area_normalised),
                       by = list('msoa11cd' = pcds_buffer_osogs_int$msoa11cd),
                       mean)

msoa_area_gdf <- merge(msoa, msoa_area, by = 'msoa11cd')
```

14. Create a static plot representing the spatial distribution in MSOA mean
postcode normalised area. Bin the data into seven equal bins and style the
classes using a sequential OS GDV colour palette. Overlay the source OS Open
GreenSpace MULTIPOLYGON feature data ontop of the thematic map.

```{r, fig.width = 10, fig.height = 10}
# Plot the MSOA mean, normalised area
msoa_plot <- tm_shape(msoa_area_gdf) + 
              tm_polygons(col = 'area_normalised', 
                          n = 7,
                          style = 'quantile',
                          palette = rev(gdv_cmap))

# Plot the green space MULTIPOLYGONS
# Transparent faces and less transparent edges
osogs_plot <- tm_shape(osogs) + 
                tm_polygons(col = '#06592a', alpha = 0.1, 
                            border.col = '#06592a', border.alpha = 0.75)

# Combine plots and display
(msoa_plot + osogs_plot)
```




